Способ 1: Нарушая инкапсуляцию
Проблемы:
    - Нарушает принцип инкапсуляции (доступ к _name, _friends, _born_in извне)
    - Тесная связь между сериализацией и внутренней структурой класса
    - При изменении внутренней структуры придется переписывать код сериализации
    - Цикличные ссылки обрабатываются через Set для отслеживания посещённых объектов
    - Хрупкий код: если переименовать приватные атрибуты, код сломается
Способ 2: Через методы
ПРЕИМУЩЕСТВА:
    - Соблюдает принцип инкапсуляции
    - Методы контролируют, какие данные выходят наружу
    - При изменении внутренней структуры обновляем только методы, не внешний код
    ПРОБЛЕМЫ:
    - Требует явной реализации методов to_dict и from_dict в каждом классе
    - Если много классов, много кода
    - Нужно передавать visited set для обработки циклов
Способ 3: Magic methods
ПРЕИМУЩЕСТВА:
    - Стандартный подход в Python (работает с pickle и другими модулями)
    - Очень элегантно и концизно
    - Python сам вызывает эти методы при нужде
    - Хорошо работает с наследованием
    ПРОБЛЕМЫ:
    - Требует знания специальных методов Python
    - При циклических ссылках нужна ручная обработка
    - Создание объекта через __new__ без конструктора может привести к неожиданному поведению
Функциональный стиль
ПРЕИМУЩЕСТВА:
    - Нет инкапсуляции по определению, всё явно
    - Простая логика: преобразуем словарь в словарь
    - Легко тестировать каждую функцию отдельно
    ПРОБЛЕМЫ:
    - Отсутствие инкапсуляции: данные открыты для любых манипуляций
    - Сложнее отследить, кто и как модифицирует данные
    - Циклические ссылки требуют явной обработки
    - Нет гарантии целостности данных (кто-то может поломать структуру)
